{"componentChunkName":"component---src-templates-blog-tsx","path":"/blog/dpdk_03/","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"DPDK 03\",\n  \"date\": \"2021-07-02T00:00:00.000Z\",\n  \"image\": \"./dpdk.png\",\n  \"banner\": \"./fast.jpg\",\n  \"description\": \"Extracting packet headers\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Introduction\"), mdx(\"p\", null, \"Hello There. Today we will parse a few layers. \"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This is the continuation of the DPDK series. You will need to have gone through \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://ibrahimshahzad.github.io/blog/dpdk_02/\"\n  }, mdx(\"font\", {\n    color: \"blue\"\n  }, \"DPDK-02\")), \". \")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Let us begin!\")), mdx(\"h1\", null, \"PreReqs\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://ibrahimshahzad.github.io/blog/dpdk_02/\"\n  }, mdx(\"font\", {\n    color: \"blue\"\n  }, \"DPDK-02\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Live dpdk binded port with traffic  \")), mdx(\"h1\", null, \"The Layers\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"To understand packet filtering, you first have to understand packets and how they are handled at each layer of the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TCP/IP\"), \" protocol stack:\", mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Application layer (e.g., FTP, Telnet, HTTP)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Transport layer (TCP or UDP)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Internet layer (IP)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Network access layer (e.g., Ethernet, FDDI, ATM)\\n\", mdx(\"img\", {\n    parentName: \"li\",\n    \"src\": \"https://i.imgur.com/adlnXNm.gif\",\n    \"alt\": \"Layers\"\n  })))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We are going to parse Ethernet, IP and Transport Layer.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will only get a few values from each and log them.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will extract following params:\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Source/Destination Mac Addresses\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"From Ethernet Layer\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Source/Destination IP\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"From IP Layer\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Source/Destination Port\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"From Transport Layer\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"let's step in our working folder\")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"bash\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"cd $RTE_SDK/examples/my_app\"), \"\\n        \"), mdx(\"h2\", null, \"Here is what we are aiming for\"), mdx(\"center\", null, mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://i.imgur.com/SoVK42r.png\",\n    \"alt\": \"design\"\n  }))), mdx(\"h2\", null, \"The Network Access Layer\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The packet here has got two parts: \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Ethernet header\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Packet kind\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Ethernet source address\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Ethernet destination address \"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Ethernet body\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"rest of packet data\")))))), mdx(\"h3\", null, \"The code\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Lets  write some code to parse the layer now.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we are going to use the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_ether_hdr\"), \" struct from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_ether.h\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"it has following members\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"struct rte_ether_addr d_addr\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"this contains destination mac address array\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"struct rte_ether_addr s_addr\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"this contains source mac address array\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ether_type\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Frame type\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"see more \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.dpdk.org/api/structrte__ether__hdr.html\"\n  }, mdx(\"font\", {\n    color: \"blue\"\n  }, \"here\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"in the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"main.c\"), \" file go to the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"worker_main\"), \" function and add a loop for going over all the packets.\")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"int worker_main(void *arg){\\n  const u_int8_t nb_ports = rte_eth_dev_count_avail();\\n  u_int8_t port;\\n  u_int8_t dest_port;\\n\\n  /* Run until app is killed or quit */\\n  for(;;){\\n    /* Receive packets on port */\\n    for(port=0;port< nb_ports;port++){\\n      struct rte_mbuf *bufs[BURST_SIZE];\\n      u_int16_t nb_rx;\\n      u_int16_t buf;\\n\\n      /* Get burst fo RX packets */\\n      nb_rx = rte_eth_rx_burst(port,0,\\n          bufs,BURST_SIZE);\\n      if (unlikely(nb_rx==0))\\n        continue;\\n\\n      for(int i =0;i<nb_rx;i++){\\n        /* Write Code here */\\n      }\\n\\n      /* send burst of Tx packets to the \\n       * second port\\n       */\\n      dest_port = port ^ 1;\\n      nb_tx= rte_eth_tx_burst(dest_port, 0,\\n          bufs, nb_rx);\\n      \\n      /* Free any unsent packets. */\\n      for (buf=0;buf<nb_rx;buf++)\\n        rte_pktmbuf_free(bufs[buf]);\\n\\n    }\\n  }\\n  return 0;\\n}\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"lets first define the ether_header\")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"struct rte_ether_hdr *ethernet_header;\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Now we will arrays to store source/destination MAC addresses\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The length of the array is defined by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RTE_ETHER_ADDR_LEN\"), \" which is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"6\"))), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"u_int8_t source_mac_address[RTE_ETHER_ADDR_LEN];\\nu_int8_t destination_mac_address[RTE_ETHER_ADDR_LEN];\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"now we use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_pktmbuf_mtod()\"), \" function\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The way to remember this function is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"packet-mbuf-to-data\"), \" function.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we populate our \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ethernet_header\"), \" struct using this.\")))), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"ethernet_header = rte_pktmbuf_mtod(bufs[i], struct rte_ether_hdr *); \"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Now we simply populate our value holders.\")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"u_int16_t ethernet_type;\\nethernet_type = ethernet_header->ether_type;\\nrte_memcpy(source_mac_address,&ethernet_header->s_addr,sizeof(u_int8_t)*RTE_ETHER_ADDR_LEN);\\nrte_memcpy(destination_mac_address,&ethernet_header->d_addr,sizeof(u_int8_t)*RTE_ETHER_ADDR_LEN);\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Finally we will log all the values extracted.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"All together it looks like below:\")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"/* Get burst fo RX packets */\\nnb_rx = rte_eth_rx_burst(port,0,\\n    bufs,BURST_SIZE);\\nif (unlikely(nb_rx==0))\\n  continue;\\n\\nfor(int i=0;i<nb_rx;i++){\\n  /* Write Code here */\\n  struct rte_ether_hdr *ethernet_header;\\n  u_int8_t source_mac_address[RTE_ETHER_ADDR_LEN];\\n  u_int8_t destination_mac_address[RTE_ETHER_ADDR_LEN];\\n  ethernet_header = rte_pktmbuf_mtod(bufs[i], struct rte_ether_hdr *); \\n  ethernet_type = ethernet_header->ether_type;\\n  rte_memcpy(source_mac_address,&ethernet_header->s_addr,sizeof(u_int8_t)*RTE_ETHER_ADDR_LEN);\\n  rte_memcpy(destination_mac_address,&ethernet_header->d_addr,sizeof(u_int8_t)*RTE_ETHER_ADDR_LEN);\\n  RTE_LOG(INFO,APP,\\\"Source Mac: \\\");\\n  for(int i=0;i<RTE_ETHER_ADDR_LEN;i++)\\n    printf(\\\"%x\\\",source_mac_address[i]);\\n  printf(\\\"\\\\n\\\");\\n  RTE_LOG(INFO,APP,\\\"Destination Mac: \\\");\\n  for(int i=0;i<RTE_ETHER_ADDR_LEN;i++)\\n    printf(\\\"%x\\\",source_mac_address[i]);\\n  printf(\\\"\\\\n\\\");\\n  RTE_LOG(INFO,APP,\\\"ether type: %d\\\",ethernet_type);\\n}\\n/* \\n* send burst of Tx packets to the \\n* second port\\n*/\\ndest_port = port ^ 1;\\nnb_tx= rte_eth_tx_burst(dest_port, 0,\\n    bufs, nb_rx);\"), \"\\n        \"), mdx(\"h2\", null, \"The Internet Layer\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This layer is responsible for routing messages between different local networks.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"IP addresses in IPv4 follow a format of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"xxx.xxx.xxx.xxx\"), \", where each decimal value (0\\u2013255) translates into 8 binary bits called an octet.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We are going to use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"struct rte_ipv4_hdr\"), \" from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_ip.h\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"contains IP-related defines\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"contains \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"struct rte_ipv4_hdr\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"struct rte_ipv6_hdr\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_ipv4_hdr\"), \" has following members\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"version_ihl\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"version and header length\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"type_of_service\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"type of service\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"total_length\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Length of packet\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"packet_id\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"packet ID\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"fragment_offset\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"fragmentation offset\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"time_to_live\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"time to live\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"next_proto_id\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"protocol ID\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"hdr_checksum\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"header checksum\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"src_addr\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"source ip address\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"dst_addr\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"destination ip address\")))))), mdx(\"h3\", null, \"The Code\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The last two bytes in the ethernet layer tell us about the next layer.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Let's write a function that will take the 16 bit value and tell us whether the layer is ipv4 or not.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the value is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"2048 (dec)\"), \" in case of ipv4\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"write down the following functions\")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"#define IPV4_PROTO 2048 \\n#define IPV6_PROTO 34525\\nu_int16_t get_Ether_Type(char *pointer)\\n{\\n    u_int8_t slb= 0;\\n    u_int8_t lb= 0;\\n    slb= *(pointer - 2 );// second last byte of ETH layer\\n    lb= *(pointer - 1 );// last last byte of ETH layer\\n    return (slb* 256) +lb;\\n}\\n\\nbool is_ipv4(u_int16_t val)\\n{\\n  if (val == IPV4_PROTO)\\n    return true;\\n  return false;\\n}\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"now let's create a pointer that we will use to traverse the packet bytes\")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"void* pHdrTraverse = (void*) ((unsigned char*) ether_header + sizeof (struct rte_ether_hdr));// Pointer to Next Layer to Eth\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"now lets call \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"get_Ether_type()\"), \" and assign the value to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"next_proto\"))), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"u_int16_t next_proto = get_Ether_Type(pHdrTraverse);// holds last two byte value of ETH Layer\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"now let's check what the next layer is\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"incase the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"next_proto\"), \" is not \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IPv4\"), \" we will log it\")))), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"if (is_ipv4(next_proto)){\\n\\n}else\\n{\\n  RTE_LOG(INFO,APP,\\\"NOT IPv4\\\\n\\\");\\n}\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"now within the if clause we will parse the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ipv4 header\"), \".\")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"struct rte_ipv4_hdr ipv4_header;\\nu_int32_t u32SrcIPv4;\\nu_int32_t u32DstIPv4;\\nipv4_header= rte_pktmbuf_mtod_offset(bufs[i], struct rte_ipv4_hdr*, sizeof (struct rte_ether_hdr));\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"okay so now the struct may be filled however, we need to check whether it is a valid ipv4 or not.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"for that we create \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"is_valid_ipv4_pkt()\"), \" function\")))), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"static inline int is_valid_ipv4_pkt(struct rte_ipv4_hdr *pkt, uint32_t link_len)\\n{\\n    /* From http://www.rfc-editor.org/rfc/rfc1812.txt section 5.2.2 */\\n    /*\\n     * 1. The packet length reported by the Link Layer must be large\\n     * enough to hold the minimum length legal IP datagram (20 bytes).\\n     */\\n    if (link_len < sizeof(struct rte_ipv4_hdr))\\n        return -1;\\n    /* 2. The IP checksum must be correct. */\\n    /* this is checked in H/W */\\n    /*\\n     * 3. The IP version number must be 4. If the version number is not 4\\n     * then the packet may be another version of IP, such as IPng or\\n     * ST-II.\\n     */\\n    if (((pkt->version_ihl) >> 4) != 4)\\n        return -3;\\n    /*\\n     * 4. The IP header length field must be large enough to hold the\\n     * minimum length legal IP datagram (20 bytes = 5 words).\\n     */\\n    if ((pkt->version_ihl & 0xf) < 5)\\n        return -4;\\n    /*\\n     * 5. The IP total length field must be large enough to hold the IP\\n     * datagram header, whose length is specified in the IP header length\\n     * field.\\n     */\\n    if (rte_cpu_to_be_16(pkt->total_length) < sizeof(struct rte_ipv4_hdr))\\n        return -5;\\n    return 0;\\n}\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"now lets call it in our if clause.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we are going to hold ipv4 src and dst addresses in unsigned int 32 variables.\")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"if (is_valid_ipv4_pkt(pIP4Hdr,bufs[i]->pkt_len)>=0){\\n    /* update TTL and CHKSM */\\n    --(pIP4Hdr->time_to_live);\\n    ++(pIP4Hdr->hdr_checksum);\\n\\n    u32SrcIPv4 = rte_bswap32(pIP4Hdr->src_addr);\\n    u32DstIPv4 = rte_bswap32(pIP4Hdr->dst_addr);\\n} else {\\n  RTE_LOG(INFO,APP,\\\"invalid IPv4\\\\n\\\");\\n}\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_bswap32\"), \" is used to swap \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"bytes\"), \" in a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"32-bit value\"), \".\")), mdx(\"h2\", null, \"The Transport Layer\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The protocols of this layer provide host-to-host communication services for applications.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Different applications use either \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TCP\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"UDP\"), \" to establish a connection.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The ports used by the application are contained within the header as the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"source port\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"destination port\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The next layer can be checked by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"next_proto_id\"), \" within the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_ipv4_hdr\"), \" struct.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We are going to extract the source and destination ports incase of\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"TCP notified by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IPPROTO_TCP\"), \" i.e. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"6\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"UDP notified by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IPPROTO_UDP\"), \" i.e. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"17\"))))))), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"switch(pIP4Hdr->next_proto_id){\\n  case IPPROTO_TCP:    \\n    break;\\n\\n  case IPPROTO_UDP: \\n      break;\\n\\n  default:\\n      u16DstPort = 0;\\n      u16SrcPort = 0;\\n      break;\\n\\n}\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Default will handle the case in which \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"next_proto_id\"), \" is neither \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TCP\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"UDP\"), \".\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will set the default value \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \" for both ports indicating this case\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Now let's parse the TCP header\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will create a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_tcp_hdr\"), \" struct contained in \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_tcp.h\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Read more about \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_tcp.h\"), \" \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://doc.dpdk.org/api/rte__tcp_8h.html\"\n  }, mdx(\"font\", {\n    color: \"blue\"\n  }, \"here\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_tcp_hdr\"), \" contains\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"src port\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"dst port\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"sent_seq\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"recv_ack\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"data_off\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"tcp_flags\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"rx_win\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"cksum\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"tcp_urp\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Read more about \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_tcp_hdr\"), \" \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://doc.dpdk.org/api/structrte__tcp__hdr.html\"\n  }, mdx(\"font\", {\n    color: \"blue\"\n  }, \"here\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Include the header \")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"include <rte_tcp.h>\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Create the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_tcp_hdr struct\"))), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"struct rte_tcp_hdr pTcpHdr;\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Lastly, handle the TCP case\")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"case IPPROTO_TCP:\\n    pTcpHdr = (struct rte_tcp_hdr *) ((unsigned char *) pIP4Hdr + sizeof(struct rte_ipv4_hdr));\\n    u16DstPort = rte_bswap16(pTcpHdr->dst_port);\\n    u16SrcPort = rte_bswap16(pTcpHdr->src_port);\\n    break;\\n\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Create the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_tcp_hdr struct\"))), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"struct rte_udo_hdr pUdpHdr;\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Lastly, handle the UDP case\")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"#include <rte_udp.h>\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will create a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_udp_hdr\"), \" struct contained in \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_udp.h\"))), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"struct rte_udp_hdr pUdpHdr;\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_udp_hdr\"), \" contains\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"src port\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"dst port\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"dgram_len\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"dgram_cksum\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Read more about \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_upd_hdr\"), \" \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.dpdk.org/api/structrte__udp__hdr.html\"\n  }, mdx(\"font\", {\n    color: \"blue\"\n  }, \"here\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Read more about \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_udp.h\"), \" \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.dpdk.org/api/rte__udp_8h.html\"\n  }, mdx(\"font\", {\n    color: \"blue\"\n  }, \"here\")))), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"case IPPROTO_UDP:\\n    pUdpHdr = (struct rte_udp_hdr *) ((unsigned char *) pIP4Hdr + sizeof (struct rte_ipv4_hdr));\\n    u16DstPort = rte_bswap16(pUdpHdr->dst_port);\\n    u16SrcPort = rte_bswap16(pUdpHdr->src_port); \\n    break;\"), \"\\n        \"), mdx(\"h1\", null, \"All Together\"), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"c\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"for(int i=0;i<nb_rx;i++){\\n    /* Write Code here */\\n    struct rte_ether_hdr *ethernet_header;\\n    u_int8_t source_mac_address[RTE_ETHER_ADDR_LEN];\\n    u_int8_t destination_mac_address[RTE_ETHER_ADDR_LEN];\\n    struct rte_ipv4_hdr     *pIP4Hdr;\\n    struct rte_ipv6_hdr     *pIP6Hdr;\\n    struct rte_udp_hdr      *pUdpHdr;\\n    struct rte_tcp_hdr      *pTcpHdr;\\n    u_int32_t u32SrcIPv4= 0;\\n    u_int32_t u32DstIPv4= 0;\\n    u_int16_t u16SrcPort= 0;\\n    u_int16_t u16DstPort= 0;\\n    u_int16_t ethernet_type;\\n    ethernet_header = rte_pktmbuf_mtod(bufs[i], struct rte_ether_hdr *);\\n    ethernet_type = ethernet_header->ether_type;\\n    rte_memcpy(source_mac_address,&ethernet_header->s_addr,sizeof(u_int8_t)*RTE_ETHER_ADDR_LEN);\\n    rte_memcpy(destination_mac_address,&ethernet_header->d_addr,sizeof(u_int8_t)*RTE_ETHER_ADDR_LEN);\\n    RTE_LOG(INFO,APP,\\\"Source Mac: \\\");\\n    for(int i=0;i<RTE_ETHER_ADDR_LEN;i++)\\n        printf(\\\"%x \\\",source_mac_address[i]);\\n    printf(\\\"\\\\n\\\");\\n    RTE_LOG(INFO,APP,\\\"Destination Mac: \\\");\\n    for(int i=0;i<RTE_ETHER_ADDR_LEN;i++)\\n        printf(\\\"%x \\\",source_mac_address[i]);\\n    printf(\\\"\\\\n\\\");\\n    RTE_LOG(INFO,APP,\\\"ether type: %d\\\",ethernet_type);\\n    void* pHdrTraverse = (void*) ((unsigned char*) ethernet_header + sizeof (struct rte_ether_hdr));// Pointer to Next Layer to Eth\\n    u_int16_t next_proto = get_Ether_Type(pHdrTraverse);// holds last two byte value of ETH Layer\\n    RTE_LOG(INFO,APP,\\\"next proto %u\\\\n\\\",next_proto);\\n    if (is_ipv4(next_proto)){\\n        pIP4Hdr = rte_pktmbuf_mtod_offset(bufs[i], struct rte_ipv4_hdr*, sizeof (struct rte_ether_hdr));\\n        /* check for valid packet */\\n        if (is_valid_ipv4_pkt(pIP4Hdr,bufs[i]->pkt_len)>=0){\\n            /* update TTL and CHKSM */\\n            --(pIP4Hdr->time_to_live);\\n            ++(pIP4Hdr->hdr_checksum);\\n            u32SrcIPv4 = rte_bswap32(pIP4Hdr->src_addr);\\n            u32DstIPv4 = rte_bswap32(pIP4Hdr->dst_addr);\\n            RTE_LOG(INFO,APP,\\\"IPv4 src %u dst %u\\\\n\\\",u32SrcIPv4,u32DstIPv4);\\n\\n            switch(pIP4Hdr->next_proto_id){\\n            case IPPROTO_TCP:\\n                pTcpHdr = (struct rte_tcp_hdr *) ((unsigned char *) pIP4Hdr + sizeof(struct rte_ipv4_hdr));\\n                u16DstPort = rte_bswap16(pTcpHdr->dst_port);\\n                u16SrcPort = rte_bswap16(pTcpHdr->src_port);\\n                break;\\n\\n            case IPPROTO_UDP:\\n                pUdpHdr = (struct rte_udp_hdr *) ((unsigned char *) pIP4Hdr + sizeof (struct rte_ipv4_hdr));\\n                u16DstPort = rte_bswap16(pUdpHdr->dst_port);\\n                u16SrcPort = rte_bswap16(pUdpHdr->src_port);\\n                break;\\n\\n            default:\\n               u16DstPort = 0;\\n               u16SrcPort = 0;\\n               break;\\n\\n            }\\n            RTE_LOG(INFO,APP,\\\"TL src %u dst %u\\\\n\\\",u16SrcPort,u16DstPort);\\n        }\\n\\n    }\\n}\"), \"\\n        \"), mdx(\"hr\", null), mdx(\"h1\", null, \"Now Lets Run this\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"First we build our program\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This should have created a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"build\"), \" directory within our directory\")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"bash\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"  make\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"now run the program using the following command\")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"bash\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"  ./build/my_app -l 0-3 -n 3 -- -p 0x3\"), \"\\n        \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"you should see some logs as following\")), mdx(\"deckgo-highlight-code\", {\n    \"language\": \"bash\",\n    \"terminal\": \"carbon\",\n    \"theme\": \"vscode\",\n    \"line-numbers\": \"true\"\n  }, \"\\n          \", mdx(\"code\", {\n    parentName: \"deckgo-highlight-code\",\n    \"slot\": \"code\"\n  }, \"  APP: Source Mac: 0 ff 56 88 84 ff\\n  APP: Destination Mac: 0 50 56 ff 84 ff\\n  APP: ether type: 8APP: next proto 2048\\n  APP: IPv4 src 3232200221 dst 1700832002\\n  APP: TL src 14550 dst 443\"), \"\\n        \"), mdx(\"h1\", null, \"WORD\"), mdx(\"center\", null, mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://i.imgflip.com/2dm9ef.jpg\",\n    \"alt\": \"Meow\"\n  }))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Have a cookiee. Treat-yo-self! We are finally done with this series\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You can look at the code \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/IbrahimShahzad/dpdk-learning\"\n  }, mdx(\"font\", {\n    color: \"blue\"\n  }, \"here\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"As always, checkout the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.dpdk.org/\"\n  }, mdx(\"font\", {\n    color: \"blue\"\n  }, \"DPDK documentation\")), \" as well.\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"DPDK 03","date":"02 July 2021","description":"Extracting packet headers","banner":{"publicURL":"/static/e3e365f7ba8597707596ef34bc88cbcc/fast.jpg","childImageSharp":{"fluid":{"srcSet":"/static/e3e365f7ba8597707596ef34bc88cbcc/9104c/fast.jpg 480w,\n/static/e3e365f7ba8597707596ef34bc88cbcc/a6352/fast.jpg 960w,\n/static/e3e365f7ba8597707596ef34bc88cbcc/d8255/fast.jpg 1920w,\n/static/e3e365f7ba8597707596ef34bc88cbcc/af56c/fast.jpg 2880w,\n/static/e3e365f7ba8597707596ef34bc88cbcc/27fce/fast.jpg 3840w,\n/static/e3e365f7ba8597707596ef34bc88cbcc/26ca3/fast.jpg 5851w","base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAByYYxKYsr/8QAGBABAQEBAQAAAAAAAAAAAAAAAREAAhD/2gAIAQEAAQUCAkzKzjQfP//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/AYj/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwGq/8QAGxAAAQQDAAAAAAAAAAAAAAAAAQIQEVEAIUH/2gAIAQEABj8CTbwBJs4rXG//xAAZEAEBAQEBAQAAAAAAAAAAAAABEQAhMUH/2gAIAQEAAT8h4RFWmg6pl9NygTEDRZLn3f/aAAwDAQACAAMAAAAQKw//xAAWEQEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQMBAT8QykP/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPxBh/8QAHRABAQACAgMBAAAAAAAAAAAAAREAITFRQXGB8P/aAAgBAQABPxBSCND5rMm00sHZ+mCWnzDfRHkSdGOhBEcdvvBEZ//Z","aspectRatio":1.5,"src":"/static/e3e365f7ba8597707596ef34bc88cbcc/d8255/fast.jpg","sizes":"(max-width: 1920px) 100vw, 1920px"},"id":"0e3c223a-438e-5a69-a6bb-905550b2fc65"}}}}},"pageContext":{"slug":"/blog/dpdk_03/"}},"staticQueryHashes":["1139857438","1946588481","2083862410","2213455283","2418326273","2889163238","3067102388"]}