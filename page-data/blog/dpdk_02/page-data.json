{"componentChunkName":"component---src-templates-blog-tsx","path":"/blog/dpdk_02/","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"DPDK 02\",\n  \"date\": \"2021-06-23T00:00:00.000Z\",\n  \"image\": \"./dpdk.png\",\n  \"banner\": \"./fast.jpg\",\n  \"description\": \"Writing the application\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Introduction\"), mdx(\"p\", null, \"In this section we will write a smiple C application to recieve packets. \"), mdx(\"p\", null, \"Let's dive in!\"), mdx(\"h1\", null, \"PreReqs\"), mdx(\"p\", null, \"Make sure that\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"DPDK is built\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"A DPDK compatible NIC is binded to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"igb_uio\"), \" driver\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Hugepages are setup\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Minimum system requirements are met\"))), mdx(\"p\", null, \"Please see \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://ibrahimshahzad.github.io/blog/Writing_your_first_dpdk_app/\"\n  }, \"DPDK-01\"), \" if any of the aforementioned pre-reqs are not set.\"), mdx(\"h1\", null, \"File Setup\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"From here on out we will refer to our dpdk installation directory as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RTE_SDK\"), \". \")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Go into the your dpdk installation directory and run the following command\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"        export RTE_SDK=$(pwd)\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The directory should contain following folders\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"        app/\\n        build/\\n        buildtools/\\n        .ci/\\n        config/\\n        devtools/\\n        doc/\\n        drivers/\\n        .editorconfig\\n        examples/\\n        .gitattributes\\n        .gitignore\\n        kernel/\\n        lib/\\n        license/\\n        MAINTAINERS\\n        Makefile\\n        meson.build\\n        meson_options.txt\\n        README\\n        .travis.yml\\n        usertools/\\n        VERSION\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"For our purposes, we are concerned with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"examples\"), \" directory and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"usertools\"), \" directory.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"examples\"), \" directory contains the example codes and we will also create our application here\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"usertools\"), \" directory contains user-help scripts such as \"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"cpu_layout.py\"), \"; prints out the Architecture  ,        \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"dpdk-devbind.py\"), \"; for binding/unbinding PCI devices,  \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"dpdk-hugepages.py\"), \"; for setting up hugepages\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"some of these we used at the time of setup.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Now, go to the examples folder and create a folder for our app\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"        cd $RTE_SDK/examples\\n        mkdir my_app\\n        cd my_app\\n\")), mdx(\"h2\", null, \"MAKE File\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"lets create a simple Makefile\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"        vim Makefile\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we are going to name our app \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"my_app\"), \" and use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"main.c\"), \" as the source c file \")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"        include $(RTE_SDK)/mk/rte.vars.mk\\n\\n        APP := my_app\\n        SRCS-y := main.c\\n\\n        include $(RTE_SDK)/mk/rte.extapp.mk  \\n\")), mdx(\"h2\", null, \"Main.c\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-C\"\n  }, \"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#include <rte_eal.h>\\n#include <rte_common.h>\\n\\n\\nint main(int argc, char* argv[]){\\n  printf(\\\"\\\\n\\\");\\n\\n  \\n\\n  return 0;\\n}\\n\")), mdx(\"h3\", null, \"EAL: \\\"Environment Abstraction Layer\\\"\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The first thing that is required is initialising up the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"EAL\"), \". We use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eal_init()\"), \" function.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It gets parameters from cli adn sets up a some of the following:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"cpu_init: fill cpu_info structure\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"log_init\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"config_init: create memory configuration in shared memory\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"pci_init: scan pci bus\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"memory_init (hugepages)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"memzone_init: initialize memzone subsystem\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"lcore_init: Create a thread per lcore\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"pci_probe: probel all physical devices\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"lets start by including \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eal.h\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"contains the EAL configuration functions\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Contains the defitnion for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eal_init()\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eal_init\"), \" returns \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-ive\"), \" in case of an error.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"See more \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.dpdk.org/api/rte__eal_8h.html#a5c3f4dddc25e38c5a186ecd8a69260e3\"\n  }, \"here\"), \".\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we will also include \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_common.h\"), \" \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It contains generic, commonly-used macro and inline function definitions for DPDK.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It contains the defitnion for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_exit()\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we would need to exit in case of an error.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"See more \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.dpdk.org/api/rte__common_8h.html\"\n  }, \"here\"))))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-C\"\n  }, \"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#include <rte_eal.h>\\n#include <rte_common.h>\\n\\n\\nint main(int argc, char* argv[]){\\n        \\n        printf(\\\"\\\\n\\\");\\n        int ret;\\n\\n        /* The EAL arguments are passed when calling the program */   \\n        ret = rte_eal_init(argc,argv);\\n        if (ret<0)\\n        rte_exit(EXIT_FAILURE,\\\"EAL Init failed\\\\n\\\");\\n\\n        argc -= ret;\\n        argv += ret;\\n        return 0;\\n}\\n\\n\")), mdx(\"h3\", null, \"Get Port Count\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We are going to be receiving on one port and transmitting on the other.\\nFor that we need even number of ports.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"lets first include \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_ethdev.h\"), \" in our program.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"includes functions to setup/configure an Ethernet device.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Ethernet devices are represented by a generic data structure of type \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eth_dev\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"contains the definition of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eth_dev_count_avail()\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"returns the total number of dpdk binded devices.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"see more \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.dpdk.org/api-17.08/rte__ethdev_8h.html\"\n  }, \"here\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"lets do that nex within our main function\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-C\"\n  }, \"  nb_ports = rte_eth_dev_count_avail();\\n  if(nb_ports < 2 || (nb_ports & 1))\\n    rte_exit(EXIT_FAILURE,\\\"Invalid port number\\\\n\\\");\\n\")), mdx(\"h3\", null, \"Logs\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We are going to include \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_log\"), \" for logging.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"contains log API to RTE applications.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"contains the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RTE_LOG()\"), \" function we are going to use for logging.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"define the User type logs as follows:   \")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-C\"\n  }, \"#define RTE_LOGTYPE_APP RTE_LOGTYPE_USER1  \\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"now update the code as follows\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-C\"\n  }, \"/*...*/\\n  nb_ports = rte_eth_dev_count_avail();\\n  if(nb_ports < 2 || (nb_ports & 1))\\n    rte_exit(EXIT_FAILURE,\\\"Invalid port number\\\\n\\\");\\n  RTE_LOG(INFO, APP, \\\"Number of ports:%u\\\\n\\\",nb_ports);\\n/*...*/\\n\")), mdx(\"h3\", null, \"MBUF Pool Creation\"), mdx(\"p\", null, \"We need to reserve some memory for holding the packets in our application. In this section we are going to do just that \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We are going to include \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_mbuf.h\"), \" for memory management.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The mbuf library provides the ability to create and destroy buffers that may be used by the RTE application to store message buffers.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we are going to use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_pktmbuf_pool_create\"), \" to create set up a buffer to hold packets. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"it uses \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"mempool\"), \" library.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Read DPDK Docs regarding \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"mbuf\"), \" \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.dpdk.org/guides/prog_guide/mbuf_lib.html\"\n  }, \"here\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.dpdk.org/blog/2019/08/21/memory-in-dpdk-part-1-general-concepts/\"\n  }, \"A good read about general concepts here\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"First We are going to define \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"NUM_MBUFS\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"MBUF_CACHE_SIZE\"), \".\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"#include <rte_mbuf.h>\\n\\n#define NB_MBUFS 8191\\n\\n#define MBUF_CACHE_SIZE 250\\n\\n#define RX_RING_SIZE 128\\n\\n#define TX_RING_SIZE 512\\n\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Now we are going to call \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_pktmbuf_pool_create\"), \" in the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"main\"), \" function.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This function creates and initializes a packet mbuf pool.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This function uses \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_memzone_reserve()\"), \" to allocate memory.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It reserves a portion of physical memory from hugepages\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Required params are as follows\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"|---------------|-------------------------------------------------------|\\n| param         |                     Description                       |\\n|---------------|-------------------------------------------------------|\\n| name          | The name of the mbuf pool. we are setting it as       |\\n|               | \\\"MBUF_POOL\\\"                                           |\\n| n             | The number of elements in the mbuf pool. We are       |\\n|               | setting it as NB_MBUF * number of ports. The optimum  |\\n|               | size (in terms of memory usage) for a mempool is when |           \\n|               |  n is a power of two minus one: n = (2^q - 1).        |\\n| cache_size    | Size of the per-core object cache.                    | \\n|               | Set to MBUF_CACHE_SIZE                                |\\n| priv_size     | Size of application private are between the rte_mbuf  |\\n|               | structure and the data buffer. Set to 0.              |\\n| data_room_size| Size of data buffer in each mbuf,                     |\\n|               | including RTE_PKTMBUF_HEADROOM.                       |\\n| socket_id     | The socket identifier where the memory should be      |\\n|               | allocated. The value can be SOCKET_ID_ANY             |\\n|               | if there is no NUMA constraint for the reserved zone. |\\n|---------------|-------------------------------------------------------|\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the creation is unsuccessful we are going to exit the program.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"/* Create a new mbuf mempool */\\n  mbuf_pool = rte_pktmbuf_pool_create(\\\"MBUF_POOL\\\",\\n      NB_MBUFS *nb_ports,\\n      MBUF_CACHE_SIZE, 0, RTE_MBUF_DEFAULT_BUF_SIZE,\\n      rte_socket_id());\\n\\n  if (mbuf_pool == NULL)\\n    rte_exit(EXIT_FAILURE,\\\"mbuff_pool create failed\\\\n\\\");\\n\")), mdx(\"h3\", null, \"Ports Initialisation\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will create a function \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \" port_init\"), \" for initialising the ports.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"port_init(u_int8_t port,struct rte_mempool *mbuf_pool){\\n  \\n  return 0;\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will loop through all the ports and initialise them one by one.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"int main(int argc, char* argv[]){\\n  /*...*/\\n  \\n  /* Initialize all ports */\\n  for (portid = 0; portid < nb_ports; portid++){\\n    if(port_init(portid,mbuf_pool) != 0)\\n      rte_exit(EXIT_FAILURE,\\\"port init failed\\\\n\\\");\\n  }\\n\\n  /*...*/\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Now lets update the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"port_init\"), \" function\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"First we set the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rte_eth_conf\")), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A structure used to configure an Ethernet port\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We can set up Receive mode and Transmit mode flags\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If you want to enable \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RSS\"), \" (Receive Side Scaling) this would be the place to start. \")))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"        struct rte_eth_conf port_conf = {\\n          .rxmode = { .max_rx_pkt_len = RTE_ETHER_MAX_LEN \\n          }\\n        };\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Now we define the rx/tx queues we are going to use per port i.e. 1 per port, lcore\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-C\"\n  }, \"        const u_int16_t nb_rx_queues = 1;\\n        const u_int16_t nb_tx_queues = 1; \\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Next we use the main function \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eth_dev_configure()\"), \" function to set up the ports.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"configures the Ethernet device. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"this function must be invoked first before any other function in the Ethernet API.\")))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-C\"\n  }, \"/* configure the ethernet device */\\n  ret = rte_eth_dev_configure(port,\\n      nb_rx_queues,\\n      nb_tx_queues,\\n      &port_conf);\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Now we allocate one \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"RX queue\"), \" per port.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will use function \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eth_rx_queue_setup()\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The function allocates a contiguous block of memory for receive descriptors\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Read more \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.dpdk.org/api/rte__ethdev_8h.html#a36ba70a5a6fce2c2c1f774828ba78f8d\"\n  }, \"here\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will set up 1 rx queue per port\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"  for (q=0;q<nb_rx_queues;q++){\\n    ret=rte_eth_rx_queue_setup(port,q,RX_RING_SIZE,\\n        rte_eth_dev_socket_id(port),\\n        NULL, mbuf_pool);\\n    if (ret<0)\\n      return ret;\\n  }\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Now we allocate one \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TX queue\"), \" per port.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will use function \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eth_tx_queue_setup()\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Allocate and set up a transmit queue for an Ethernet device.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Read more \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://doc.dpdk.org/api/rte__ethdev_8h.html#a796c2f20778984c6f41b271e36bae50e\"\n  }, \"here\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will set up 1 tx queue per port\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"  for (q=0;q<nb_tx_queues;q++){\\n    ret=rte_eth_tx_queue_setup(port,q,TX_RING_SIZE,\\n      rte_eth_dev_socket_id(port),\\n      NULL);\\n    if (ret<0)\\n      return ret;\\n  }\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"All togethor now:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"int port_init(u_int8_t port,struct rte_mempool *mbuf_pool){\\n\\n  struct rte_eth_conf port_conf = {\\n        .rxmode = { .max_rx_pkt_len = ETHER_MAX_LEN }\\n        };\\n  \\n  const u_int16_t nb_rx_queues = 1;\\n  const u_int16_t nb_tx_queues = 1;\\n  int ret;\\n\\n  /* configure the ethernet device */\\n  ret = rte_eth_dev_configure(port,\\n                nb_rx_queues,\\n                nb_tx_queues,\\n                &port_conf);\\n  if (ret != 0)\\n    return ret;\\n  \\n  /* Allocate and setup 1 RX queue per Ethernet port */\\n  for (q=0;q<nb_rx_queues;q++){\\n    ret=rte_eth_queue_setup(port,q,RX_RING_SIZE,\\n                        rte_eth_dev_socket_id(port),\\n                        NULL, mbuf_pool);\\n    if (ret<0)\\n     return ret;\\n  }\\n\\n  /* Allocate and setup 1 RX queue per Ethernet port */\\n  for (q=0;q<nb_tx_queues;q++){\\n    ret=rte_eth_tx_queue_setup(port,q,TX_RING_SIZE,\\n      rte_eth_dev_socket_id(port),\\n      NULL);\\n  \\n    if (ret<0)\\n      return ret;\\n  }\\n  \\n  return 0;\\n\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Finally, we start the device using \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eth_dev_start()\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we will also enable promisuous mode \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eth_promiscuous_enable()\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"in \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"promiscuous\"), \" mode every data packet transmitted can be received and read by a network adapter\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Update the main function as follows\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"/* start the ethernet port */\\nret = rte_eth_dev_start(port);\\n\\nif (ret<0){\\n  return ret;\\n}\\n\\n/* Enable RX in promiscuous mode for the Ethernet device */\\nrte_eth_promiscuous_enable(port);\\n\\n\")), mdx(\"h3\", null, \"Check Link Status\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We are going to create a new function to check the link status of the ports\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It is going to tell us which of the links are up and which are down.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-C\"\n  }, \"static int check_link_status(u_int16_t nb_ports){\\n  struct rte_eth_link link;\\n  u_int8_t port;\\n  for (port=0;port<nb_ports;port++){\\n    rte_eth_link_get(port,&link);\\n    if(link.link_status == ETH_LINK_DOWN){\\n      RTE_LOG(INFO,APP,\\\"Port: %u Link DOWN\\\\n\\\",port);\\n      return -1;\\n    }\\n    RTE_LOG(INFO,APP,\\\"Port: %u Link UP Speed %u\\\\n\\\",\\n        port,link.link_speed);\\n  }\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Now we can call our function in the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"main()\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-C\"\n  }, \"ret=check_link_status(nb_ports);\\n  if (ret<0){\\n    RTE_LOG(WARNING,APP,\\\"Some ports are down\\\\n\\\");\\n  }\\n\")), mdx(\"h3\", null, \"Workers Init\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will create a worker function that will run all the cores\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This worker will be responsible for\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"receiving packets\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"parsing packets\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"transmitting packets\")))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"int worker_main(void *arg){\\n  /* Run until app is killed or quit */\\n  for(;;){\\n\\n  }\\n  return 0;\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In the main program we will launch the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"woker_main()\"), \" function on all the lcores available\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eal_mp_remote_launch()\"), \" for this\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Launches a function on all lcores\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"first argument is the function name (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"worker_main\"), \") that needs to be launched on all cores\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The next argrument takes in the arguments that need to be passed. Since we have nothing to pass we will set this as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"NULL\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The third arguemnt specifies whether the function needs to run on all cores \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"including \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"MASTER\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"MAIN\"), \" core (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"CALL_MAIN\"), \" flag)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"excluding \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"MASTER\"), \"/\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"MAIN\"), \" core (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SKIP_MAIN\"), \" flag)\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Then we use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eal_mp_wait_lcore\"), \" so that \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"MASTER\"), \" core waits for other worker cores.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This keeps the program from exiting.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We can print stats on master core if needed.\")))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"  ret=check_link_status(nb_ports);\\n  if (ret<0){\\n    RTE_LOG(WARNING,APP,\\\"Some ports are down\\\\n\\\");\\n  }\\n  rte_eal_mp_remote_launch(worker_main,NULL,SKIP_MAIN);\\n  rte_eal_mp_wait_lcore();\\n\")), mdx(\"h3\", null, \"Receive/Transmit Packets\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Lets define the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"BURST_SIZE\"), \" first.\\n=  This defines how many packets will the core pick up at a time.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"  #define BURST_SIZE 32\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In the worker_main we will set up struct rte_mbuf array that will be of the size \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"BURST_SIZE\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This will be defined by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"struct rte_mbuf *bufs[BURST_SIZE];\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will recieve packets using \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eth_rx_burst\"), \" function\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It requires \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"port\"), \" number on which to receive\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"queue\"), \" number on which to receive\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_mbuf\"), \" structure to hold the packets\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Number of packets to receive.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It will return the total number of packets received (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"nb_rx\"), \")\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will transmit the recieved packets on the opposite port.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Receive on \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\"), \", send on \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Receive on \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \", send on \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\")))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For Transmitting we use the function \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eth_tx_burst\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"port\"), \" number on which to transmit\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"queue\"), \" number on which to transmit\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_mbuf\"), \" structure that holds the packets\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Number of packets to transmit\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"After that we will loop through packets again and free all the unsent packets\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"packets are freed using \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_pktmbuf_free()\"), \" function\")))))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"int worker_main(void *arg){\\n  const u_int8_t nb_ports = rte_eth_dev_count_avail();\\n  u_int8_t port;\\n  u_int8_t dest_port;\\n\\n  /* Run until app is killed or quit */\\n  for(;;){\\n    /* Receive packets on port */\\n    for(port=0;port< nb_ports;port++){\\n      struct rte_mbuf *bufs[BURST_SIZE];\\n      u_int16_t nb_rx;\\n      u_int16_t buf;\\n\\n      /* Get burst fo RX packets */\\n      nb_rx = rte_eth_rx_burst(port,0,\\n          bufs,BURST_SIZE);\\n      if (unlikely(nb_rx==0))\\n        continue;\\n\\n      /* send burst of Tx packets to the \\n       * second port\\n       */\\n      dest_port = port ^ 1;\\n      nb_tx= rte_eth_tx_burst(dest_port, 0,\\n          bufs, nb_rx);\\n      \\n      /* Free any unsent packets. */\\n      for (buf=0;buf<nb_rx;buf++)\\n        rte_pktmbuf_free(bufs[buf]);\\n\\n    }\\n  }\\n  return 0;\\n}\\n\")), mdx(\"h3\", null, \"Some Stats\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Lets print some stats when we exit the program.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We'll need to add the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"signal handler\"), \" to first catch the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"interrupt\"), \".\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"First lets create a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"flag\"), \" that we will change when the signal is caught\")))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-C\"\n  }, \"static volatile bool force_quit;\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Now the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"handler\"), \" which updates the flag and displays the the stats\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-C\"\n  }, \"static void\\nsignal_handler(int signum){\\n  if(signum== SIGINT || signum== SIGTERM){\\n    printf(\\\"\\\\n\\\\nSignal %d received,preparing to exit...\\\\n\\\",signum);\\n    force_quit = true;\\n    print_stats();\\n  }\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"lets register\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"add following in the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"main\"), \" function\")))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"   force_quit = false;\\n   signal(SIGINT,signal_handler);\\n   signal(SIGTERM,signal_handler);\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"update the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"for loop\"), \" condition in \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"worker_main\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"while(!force_quit)\"), \" instead of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"for(;;)\"), \" \"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Lastly, lets create a function to display the stats\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It uses the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eth_stats\"), \" struct and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eth_stats_get\"), \" function \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the function takes in \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"port_id\"), \" for which the stats are required and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eth_stats\"), \" struct\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It fills the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"rte_eth_stats\"), \" struct which contains\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ipackets\"), \": packets received by the interface\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"opackets\"), \": packets sent by the interface\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"imissed\"), \": packets dropped by the interface\")))))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-c\"\n  }, \"static void\\nprint_stats(void){\\n  struct rte_eth_stats stats;\\n  u_int8_t nb_ports = rte_eth_dev_count_avail();\\n  u_int8_t port;\\n\\n  for(port=0;port<nb_ports;port++){\\n    printf(\\\"\\\\nStatistics for the port %u\\\\n\\\",port);\\n    rte_eth_stats_get(port,&stats);\\n    printf(\\\"RX:%911u Tx:%911u dropped:%911u\\\\n\\\",\\n        stats.ipackets,stats.opackets,stats.imissed);\\n  }\\n}\\n\")), mdx(\"hr\", null), mdx(\"h2\", null, \"Now Lets Run this\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"First we build our program\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"this should have created a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"build\"), \" directory within our directory\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"        make\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will pass our program arguments just like \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"L2FWD\"), \".\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-l\"), \" will indicate cores\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"-p\"), \" will indicate portmask\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x1\"), \" indicates 1 port i.e binary mask \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0001\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x3\"), \" indicates 2 port i.e binary mask \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0011\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x7\"), \" indicates 3 port i.e binary mask \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0111\"))))))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"        ./build/my_app -l 0-3 -n 3 -- -p 0x3\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"you should see something like\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"EAL: Detected 18 lcore(s)\\nEAL: Detected 1 NUMA nodes\\nEAL: Detected shared linkage of DPDK\\nEAL: Multi-process socket /var/run/dpdk/rte/mp_socket\\nEAL: Selected IOVA mode 'PA'\\nEAL: No available hugepages reported in hugepages-2048kB\\nEAL: Probing VFIO support...\\nEAL: VFIO support initialized\\nEAL:   Invalid NUMA socket, default to 0\\nEAL:   Invalid NUMA socket, default to 0\\nEAL:   Invalid NUMA socket, default to 0\\nEAL:   Invalid NUMA socket, default to 0\\nEAL: No legacy callbacks, legacy socket not created\\nAPP: Number of ports:2\\nAPP: MAC address swapping enabledi\\nAPP: Port: 0 Link UP Speed 10000\\nAPP: Port: 1 Link UP Speed 10000\\nAPP: Some ports are down\\nAPP: lcore 2 exiting\\nAPP: lcore 3 exiting\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Press \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Ctrl-C\"), \" to exit the program and print some stats\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"Signal 2 received,preparing to exit...\\n\\nStatistics for the port 0\\nRX: 0           Tx: 13664640    dropped: 0\\n\\nStatistics for the port 1\\nRX: 13664640    Tx: 0           dropped: 0\\n\")), mdx(\"hr\", null), mdx(\"h1\", null, \"WORD\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://i.kym-cdn.com/entries/icons/original/000/035/692/cover1.jpg\",\n    \"alt\": \"Meow\"\n  })), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Give yourself a pat on the back you are done. (FOR NOW!)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We will parse a few layers in the next one.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"I followed \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/ferruhy/dpdk-simple-app\"\n  }, \"ferruhy/dpdk-simple-app\"), \" and it was of a great help to me. \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Please do check his repo out.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Infact this whole thing was inspired by this simple learning repo of his.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You can look at the code \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/IbrahimShahzad/dpdk-learning\"\n  }, \"here\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.dpdk.org/\"\n  }, \"Checkout the DPDK documentation as well.\"))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"DPDK 02","date":"23 June 2021","description":"Writing the application","banner":{"publicURL":"/static/e3e365f7ba8597707596ef34bc88cbcc/fast.jpg","childImageSharp":{"fluid":{"srcSet":"/static/e3e365f7ba8597707596ef34bc88cbcc/9104c/fast.jpg 480w,\n/static/e3e365f7ba8597707596ef34bc88cbcc/a6352/fast.jpg 960w,\n/static/e3e365f7ba8597707596ef34bc88cbcc/d8255/fast.jpg 1920w,\n/static/e3e365f7ba8597707596ef34bc88cbcc/af56c/fast.jpg 2880w,\n/static/e3e365f7ba8597707596ef34bc88cbcc/27fce/fast.jpg 3840w,\n/static/e3e365f7ba8597707596ef34bc88cbcc/26ca3/fast.jpg 5851w","base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAByYYxKYsr/8QAGBABAQEBAQAAAAAAAAAAAAAAAREAAhD/2gAIAQEAAQUCAkzKzjQfP//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/AYj/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwGq/8QAGxAAAQQDAAAAAAAAAAAAAAAAAQIQEVEAIUH/2gAIAQEABj8CTbwBJs4rXG//xAAZEAEBAQEBAQAAAAAAAAAAAAABEQAhMUH/2gAIAQEAAT8h4RFWmg6pl9NygTEDRZLn3f/aAAwDAQACAAMAAAAQKw//xAAWEQEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQMBAT8QykP/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPxBh/8QAHRABAQACAgMBAAAAAAAAAAAAAREAITFRQXGB8P/aAAgBAQABPxBSCND5rMm00sHZ+mCWnzDfRHkSdGOhBEcdvvBEZ//Z","aspectRatio":1.5,"src":"/static/e3e365f7ba8597707596ef34bc88cbcc/d8255/fast.jpg","sizes":"(max-width: 1920px) 100vw, 1920px"},"id":"e3220174-671a-5ead-8edb-06b279a6b662"}}}}},"pageContext":{"slug":"/blog/dpdk_02/"}},"staticQueryHashes":["1139857438","1946588481","2083862410","2213455283","2418326273","2889163238","3067102388"]}